.. _setting_up_dev_env:

Setting up a development environment
====================================

Nix_ is used heavily in the Batsim ecosystem.
Not only to distribute the software to end users,
but also to manage the build and test environments of the various tools.
In the end, we recommend Nix to any Batsim user or developer:

- For end users,
  it provides controlled environments to execute your simulations,
  which helps a lot in making your experiments repeatable
  (yes, you/your advisors/your reviewers/etc. want them to be repeatable :p).
  It also avoids the hassle of installing dependencies.
  Please give a look at :ref:`using_batsim_from_well_defined_nix_env` for a simple Nix usage in this case,
  or follow our :ref:`tuto_reproducible_experiment` tutorial to see more advanced usage (tuning/pinning the versions of the various tools).
- For developers getting started with Batsim,
  we provide environments to build or test Batsim,
  which means no hassle to install dependencies regardless of your Linux distribution or operating system.
  It also means that you can trivially share your development environment,
  which will enable us to help you more easily if you :ref:`contact_us`.
- For advanced Batsim developers,
  Nix's full power can be unleashed to tune various packages at the same time while remaining clean/reproducible/shareable with other developers.
  This is especially useful when adding a new Batsim feature that involves modifying Batsim and schedulers at the same time — or when you also need to modify SimGrid for your work.

Nix architecture
----------------

Most of our packages are defined in the `NUR-Kapack`_ repository.
The default versions of packages defined in NUR-Kapack are meant to be used for end users: Optimized binaries without debug information.

The daily environment used to build and test Batsim (by developers or :ref:`ci` machines) is different, as in this case we want debug information on Batsim but also on its dependencies, notably SimGrid.
All of this environment is defined in :download:`default.nix <../default.nix>`, located at the root of Batsim's git repository.
This file reuses the package definitions from NUR-Kapack and *overrides* them to have the desired behavior.
This file defines a Nix *set*, that is to say a structure that associates names (*attributes*) to packages or environments (*derivations*).
Here is an overview of the various attributes of this file:

- ``batsim`` defines a package that builds the Batsim executable (and coverage information generated by gcov at compile time). This package may also run unit tests and generate coverage information about them.
- ``integration_tests`` defines a package that runs Batsim integration tests and generates test report and coverage information.
- ``coverage-report`` combines gcov information to generate readable coverage reports.
- ``sphinx_doc`` generates Batsim's sphinx documentation (you are currently reading it).
- ``doxydoc`` generates Batsim's code doxygen documentation.

Basic usage with ``nix-build``
------------------------------

Most of our *attributes* are meant to be used easily with ``nix-build``.
As the name says, ``nix-build`` builds a Nix expression and puts the result files in the Nix store — a ``./result`` symlink is also produced so you can easily give a look at the files generated by the command.

You can for example build a debug version of Batsim from local sources with ``nix-build -A batsim``, then run it with ``./result/bin/batsim`` (do not worry if you see many warning lines about profiling/gcda files, this is a normal artifact of our gcov usage).

.. note::

    The first time you call this command, Nix may compile many dependencies if they are not present in your machine's cache.
    Most dependencies are likely to be present in Batsim's binary cache, so you can simply download them from there if you want to save some time — refer to :ref:`using_nix_introduction` to enable fetching data from Batsim's binary cache with ``cachix``.

You can then run integration tests with ``nix-build -A integration_tests``.
Please note that Nix will compile/download any needed dependency when this command is called. Here, this means that Batsim (from the ``batsim`` attribute) will be compiled if needed, or schedulers (``batsched`` and ``pybatsim`` attributes), or tools to run the tests (``pytest`` and ``batexpe``).

Finally, you can see which Batsim code lines are covered by our tests by calling ``nix-build -A coverage-report``. By default, this should generate textual reports (plain text, CSV and JSON) — ``cat ./result/file-summary.txt`` prints one of the generated files. You can enable many other output formats by setting Nix variables when calling commands. For example, ``nix-build --arg coverageHtml true -A coverage-report`` will generate human readable html files where you can browse lines of code and see whether they are covered or not with ``firefox ./result/html/index.html``. For a list of available arguments, please read the first lines of :download:`default.nix <../default.nix>`.

.. warning::

    By default, the ``integration_tests`` attribute will always be rebuilt (when you call ``nix-build -A integration_tests`` directly or when you use any attribute that requires it such as ``nix-build -A coverage-report``).
    This is done voluntarily as some tests may have non-deterministic outcome and we want to easily run them many times in a row.

    If for some reason you want to avoid rebuilds (typically if you want to generate coverage reports from an existing test run), you can define the ``testVersion`` Nix variable to a fixed value when running your commands: ``nix-build --argstr testVersion fixed -A integration_tests`` then ``nix-build --argstr testVersion fixed -A coverage-report``. You can put any value instead of ``fixed`` as long as you use the same value in all your commands.

.. _iterative_builds_with_nix_shell:

Iterative builds with ``nix-shell``
-----------------------------------
``nix-build -A batsim`` makes sure that Batsim is built correctly by building Batsim sources from scratch every time. This is an interesting property, but sometimes you just want to compile many times in rapid succession, and keeping/updating a build cache to compile Batsim can be very useful.
The simplest way to achieve this is to get into an environment that can build Batsim, and to compile it manually from there.

- Enter shell that can build Batsim: ``nix-shell -A batsim``
- From inside the shell, generate a Meson build directory if it does not already exist: ``meson build``
- From inside the shell, compile Batsim: ``ninja -C build``

You should now be able to edit your code however you want then call ``ninja -C build`` to trigger a Batsim build with cache.

.. warning::

    Please note that you may need to recreate the build directory depending on what you do. Typically, whenever you add new files or change the include graph of the project, creating a new build directory is advised.

.. _using_ides_such_as_qtcreator:

Using IDEs such as ``qtcreator``
--------------------------------

Depending on what development you are doing, using an IDE such as ``qtcreator`` can be useful to edit source code.
This is completely doable, but you have to make sure to run your IDE from the right environment.
Assuming that ``qtcreator`` is already installed in your local environment, you can follow these steps to make it able to build Batsim.

- Enter a shell that can build Batsim with CMake: ``nix-shell -A batsim_cmake``
- From inside the shell, generate a CMake build directory if it does not already exist: ``(mkdir build-cmake && cd build-cmake && cmake .. && make -j $(nproc))``
- From inside the shell, run qtcreator to import an existing CMake project: ``qtcreator ./CMakeLists.txt &``. When qtcreator prompts you about how to import the project, tell it to only use the existing build environment/directory and **not** to create a new one.
- You should now be able to compile Batsim from qtcreator.

.. _run_tests_from_iteratively_built_batsim:

Run tests from iteratively-built Batsim
---------------------------------------

Sometimes, you want to run some Batsim integration tests from an iteratively-built Batsim. Typically, this happens when you are making a single test pass and you want to do fast build/test iterations.
This can be done by using several environments at the same time:

- Keep a first environment open, in which you build Batsim. These environments can be :ref:`iterative_builds_with_nix_shell` or :ref:`using_ides_such_as_qtcreator` for example.
- Keep a second *hacky* environment open, in which you run the tests.

You can create the second environment by calling ``nix-shell -A integration_tests`` — **the following commands of this section are to be executed in the shell created by this nix-shell command**.
The default ``batsim`` executable in this environment is the one built cleanly by Nix.
You can call ``which batsim`` to see where the ``batsim`` executable is located (spoiler: in the Nix store).
As Batsim integration tests simply run Batsim by calling a ``batsim`` command,
**you can hack the test environment to run your iteratively built Batsim by hacking your PATH environment variable**. For example, if your Batsim build cache directory is in ``${HOME}/proj/batsim/build``, you can hack your call path via this command: ``export PATH="${HOME}/proj/batsim/build:${PATH}"``.
To make sure the hack worked, call ``which batsim`` to make sure that ``batsim`` now references your iteratively built file.

Now, in the second shell, you can go into the ``test`` directory (from Batsim's root directory) and run tests how you want (``pytest`` will run all tests, ``pytest test_energy.py`` will run energy tests...).

Running a simulation instance with gdb
--------------------------------------
Sometimes, you want to run Batsim/the scheduler/both with a debugger to see what's going on — typically when a test fails and you modify Batsim's source code in a trial and error method. This section shows how this can be done (we will only run Batsim with a debugger here).

First, please read :ref:`run_tests_from_iteratively_built_batsim`, as this section is a direct continuation to it. Here, we will need three environments:

- A first environment to build Batsim iteratively.
  Make sure to build Batsim without optimization and with debug information (DWARF symbols).
  This should be done by default by Meson but you can force it if needed, refer to `Running Meson`_ and `Meson's built-in options`_ in this case.
  Calling ``file ./build/batsim`` on your iteratively built batsim should show whether debug information is present or not (``with debug_info, not stripped``).
- A second environment to execute Batsim.
  A starting point of this environment is the one defined in :ref:`run_tests_from_iteratively_built_batsim`.
  **Unless stated explicitly, all commands listed in the following of this section are to be run in this environment**.
- A third environment to execute the scheduler.
  As here we won't modify the scheduler, just use ``nix-shell -A integration_tests``.

The main entry point of Batsim's integration tests is to call pytest, that will generate many simulation instances and run them. Most simulation instances consist in calling ``batsim`` with some command-line arguments, and a scheduler (typically ``batsched``, sometimes ``pybatsim``) with some command-line arguments. A wrapper process called ``robin`` is in charge of executing both commands and of handling errors (typically, kill batsim when scheduler crashes and vice versa, or kill everyone when a timeout is reached to avoid infinite loops). When ``robin`` runs a simulation instance, it generates separate scripts to run Batsim and the scheduler. Here, we will see how these scripts can be hacked to run Batsim from gdb.

First, clean the output directory of Batsim's tests, which is located in ``test/test-out`` from Batsim's source directory.
Then, run integration tests with ``pytest`` from the ``test`` directory  — here we will assume that one of the tests defined in ``test_walltime.py`` fails so we will run ``pytest test_walltime.py``.
Running this command will populate the ``test-out`` directory with many tests: A directory is created per simulation instance, and an ``instance.yaml`` file describes how to run each instance.
You can manually run a simulation instance by calling ``robin instance.yaml`` (assuming your have moved your current working directory to the test you want to work on).
You can run several tests until you find the one that fails.
Now, assuming you found the failing test you want to work on, you can give a look at the test directory structure — ``tree`` should output something like this:

.. code-block:: text

    .
    ├── batres_jobs.csv
    ├── batres_machine_states.csv
    ├── batres_schedule.csv
    ├── batres_schedule.trace
    ├── cmd
    │   ├── batsim.bash
    │   └── sched.bash
    ├── instance.yaml
    └── log
        ├── batsim.log
        ├── sched.err.log
        └── sched.out.log

- Files that start with ``batres_`` are simulation results generated by Batsim.
- The ``log`` directory contains the logs of the batsim/scheduler commands.
- The ``cmd`` directory contains the commands that were run by robin.

You can now run the simulation instance without robin, by calling ``batsim`` and the scheduler in their own shells.

- In the shell configured to run your iteratively built Batsim, you can run ``./cmd/batsim.bash``.
- In the shell for the scheduler, you can run ``./cmd/sched.bash``.

Now you just have to hack ``./cmd/batsim.bash`` so that it runs ``batsim`` with your favorite debugger, and execute both scripts in their own shells again. As I personally use ``gdb`` with the cgdb_ terminal interface, so I just prefix the Batsim command with ``cgdb --args`` to run it inside my debugger.

.. note::

  Your debugger may not display some source files.
  This should not happen for Batsim source code, but it may happen for dependencies such as SimGrid, in which case you can observe something like this:

  .. code-block:: text

      (gdb)
      #8  0x00007ffff7a1270c in simgrid::kernel::context::Context::operator() (this=0x7f9d00) at ../src/kernel/context/Context.hpp:65
      65      ../src/kernel/context/Context.hpp: No such file or directory.

  If you want to display SimGrid source code, clone SimGrid's source code somewhere in your filesystem (make sure to checkout the exact same version as the one defined in :download:`default.nix <../default.nix>`/`NUR-Kapack`_) and tell your debugger where to find source files. If you cloned SimGrid in ``/home/user/proj/simgrid-release`` and you use ``gdb``, this is done by typing ``dir /home/user/proj/simgrid-release/src`` in gdb's interactive interface.

  You can do the exact same trick for any source code that your debugger cannot find. You can also create initialization files for your debugger to load these directories automatically.

Hacking several packages at the same time
-----------------------------------------
Sometimes, you not only need to hack Batsim but also one of its dependency (SimGrid, intervalset...) or a scheduler (batsched, pybatsim).
This is for example the case when you add a protocol feature.

.. todo::

    Write a simple SimGrid/batsched/pybatsim hack example.

    For now, please refer to the :ref:`tuto_reproducible_experiment` tutorial that do similar Nix manipulations, or :ref:`contact_us` if you need help with this.


.. _Nix: https://nixos.org/nix/
.. _NUR-Kapack: https://github.com/oar-team/nur-kapack
.. _Running Meson: https://mesonbuild.com/Running-Meson.html
.. _Meson's built-in options: https://mesonbuild.com/Builtin-options.html
.. _cgdb: https://cgdb.github.io/
